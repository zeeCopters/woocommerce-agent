{"version":3,"file":"responses.js","names":["schema: Record<string, unknown>","tool: {\n      type: \"function\";\n      function: FunctionDefinition;\n    }","options?: ToolStrategyOptions","schema: InteropZodObject | Record<string, unknown>","outputOptions?: ToolStrategyOptions","name?: string","asJsonSchema","tool","functionDefinition: FunctionDefinition","toolArgs: Record<string, unknown>","schema: InteropZodType<T> | Record<string, unknown>","response: AIMessage","responseFormat?:\n    | InteropZodType<any>\n    | InteropZodType<any>[]\n    | JsonSchemaFormat\n    | JsonSchemaFormat[]\n    | ResponseFormat\n    | ToolStrategy<any>[]\n    | ResponseFormatUndefined","model?: LanguageModelLike | string","responseFormat:\n    | InteropZodType<any>\n    | InteropZodType<any>[]\n    | JsonSchemaFormat\n    | JsonSchemaFormat[]","responseFormat: InteropZodType<any> | JsonSchemaFormat"],"sources":["../../src/agents/responses.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-instanceof/no-instanceof */\nimport {\n  InteropZodObject,\n  isInteropZodSchema,\n  InteropZodType,\n  isInteropZodObject,\n} from \"@langchain/core/utils/types\";\nimport { type AIMessage } from \"@langchain/core/messages\";\nimport { type LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport { toJsonSchema, Validator } from \"@langchain/core/utils/json_schema\";\nimport { type FunctionDefinition } from \"@langchain/core/language_models/base\";\n\nimport {\n  StructuredOutputParsingError,\n  MultipleStructuredOutputsError,\n} from \"./errors.js\";\nimport { isConfigurableModel, isBaseChatModel } from \"./model.js\";\n\n/**\n * Special type to indicate that no response format is provided.\n * When this type is used, the structuredResponse property should not be present in the result.\n */\nexport type ResponseFormatUndefined = {\n  __responseFormatUndefined: true;\n};\n\n/**\n * This is a global counter for generating unique names for tools.\n */\nlet bindingIdentifier = 0;\n\n/**\n * Information for tracking structured output tool metadata.\n * This contains all necessary information to handle structured responses generated\n * via tool calls, including the original schema, its type classification, and the\n * corresponding tool implementation used by the tools strategy.\n */\nexport class ToolStrategy<_T = unknown> {\n  private constructor(\n    /**\n     * The original JSON Schema provided for structured output\n     */\n    public readonly schema: Record<string, unknown>,\n\n    /**\n     * The tool that will be used to parse the tool call arguments.\n     */\n    public readonly tool: {\n      type: \"function\";\n      function: FunctionDefinition;\n    },\n\n    /**\n     * The options to use for the tool output.\n     */\n    public readonly options?: ToolStrategyOptions\n  ) {}\n\n  get name() {\n    return this.tool.function.name;\n  }\n\n  static fromSchema<S extends InteropZodObject>(\n    schema: S,\n    outputOptions?: ToolStrategyOptions\n  ): ToolStrategy<S extends InteropZodType<infer U> ? U : unknown>;\n\n  static fromSchema(\n    schema: Record<string, unknown>,\n    outputOptions?: ToolStrategyOptions\n  ): ToolStrategy<Record<string, unknown>>;\n\n  static fromSchema(\n    schema: InteropZodObject | Record<string, unknown>,\n    outputOptions?: ToolStrategyOptions\n  ): ToolStrategy<any> {\n    /**\n     * It is required for tools to have a name so we can map the tool call to the correct tool\n     * when parsing the response.\n     */\n    function getFunctionName(name?: string) {\n      return name ?? `extract-${++bindingIdentifier}`;\n    }\n\n    if (isInteropZodSchema(schema)) {\n      const asJsonSchema = toJsonSchema(schema);\n      const tool = {\n        type: \"function\" as const,\n        function: {\n          name: getFunctionName(),\n          strict: false,\n          description:\n            asJsonSchema.description ??\n            \"Tool for extracting structured output from the model's response.\",\n          parameters: asJsonSchema,\n        },\n      };\n      return new ToolStrategy(asJsonSchema, tool, outputOptions);\n    }\n\n    let functionDefinition: FunctionDefinition;\n    if (\n      typeof schema.name === \"string\" &&\n      typeof schema.parameters === \"object\" &&\n      schema.parameters != null\n    ) {\n      functionDefinition = schema as unknown as FunctionDefinition;\n    } else {\n      functionDefinition = {\n        name: getFunctionName(schema.title as string),\n        description: (schema.description as string) ?? \"\",\n        parameters: schema.schema || (schema as Record<string, unknown>),\n      };\n    }\n    const asJsonSchema = toJsonSchema(schema);\n    const tool = {\n      type: \"function\" as const,\n      function: functionDefinition,\n    };\n    return new ToolStrategy(asJsonSchema, tool, outputOptions);\n  }\n\n  /**\n   * Parse tool arguments according to the schema.\n   *\n   * @throws {StructuredOutputParsingError} if the response is not valid\n   * @param toolArgs - The arguments from the tool call\n   * @returns The parsed response according to the schema type\n   */\n  parse(toolArgs: Record<string, unknown>): Record<string, unknown> {\n    const validator = new Validator(this.schema);\n    const result = validator.validate(toolArgs);\n    if (!result.valid) {\n      throw new StructuredOutputParsingError(\n        this.name,\n        result.errors.map((e) => e.error)\n      );\n    }\n    return toolArgs;\n  }\n}\n\nexport class ProviderStrategy<T = unknown> {\n  // @ts-expect-error - _schemaType is used only for type inference\n  private _schemaType?: T;\n\n  private constructor(public readonly schema: Record<string, unknown>) {}\n\n  static fromSchema<T>(schema: InteropZodType<T>): ProviderStrategy<T>;\n\n  static fromSchema(\n    schema: Record<string, unknown>\n  ): ProviderStrategy<Record<string, unknown>>;\n\n  static fromSchema<T = unknown>(\n    schema: InteropZodType<T> | Record<string, unknown>\n  ): ProviderStrategy<T> | ProviderStrategy<Record<string, unknown>> {\n    const asJsonSchema = toJsonSchema(schema);\n    return new ProviderStrategy(asJsonSchema) as\n      | ProviderStrategy<T>\n      | ProviderStrategy<Record<string, unknown>>;\n  }\n\n  /**\n   * Parse tool arguments according to the schema. If the response is not valid, return undefined.\n   *\n   * @param toolArgs - The arguments from the tool call\n   * @returns The parsed response according to the schema type\n   */\n  parse(response: AIMessage) {\n    /**\n     * return if the response doesn't contain valid content\n     */\n    if (typeof response.content !== \"string\" || response.content === \"\") {\n      return;\n    }\n\n    try {\n      const content = JSON.parse(response.content);\n      const validator = new Validator(this.schema);\n      const result = validator.validate(content);\n      if (!result.valid) {\n        return;\n      }\n\n      return content;\n    } catch {\n      // no-op\n    }\n  }\n}\n\nexport type ResponseFormat = ToolStrategy<any> | ProviderStrategy<any>;\n\n/**\n * Handle user input for `responseFormat` parameter of `CreateAgentParams`.\n * This function defines the default behavior for the `responseFormat` parameter, which is:\n *\n * - if value is a Zod schema, default to structured output via tool calling\n * - if value is a JSON schema, default to structured output via tool calling\n * - if value is a custom response format, return it as is\n * - if value is an array, ensure all array elements are instance of `ToolStrategy`\n * @param responseFormat - The response format to transform, provided by the user\n * @param options - The response format options for tool strategy\n * @param model - The model to check if it supports JSON schema output\n * @returns\n */\nexport function transformResponseFormat(\n  responseFormat?:\n    | InteropZodType<any>\n    | InteropZodType<any>[]\n    | JsonSchemaFormat\n    | JsonSchemaFormat[]\n    | ResponseFormat\n    | ToolStrategy<any>[]\n    | ResponseFormatUndefined,\n  options?: ToolStrategyOptions,\n  model?: LanguageModelLike | string\n): ResponseFormat[] {\n  if (!responseFormat) {\n    return [];\n  }\n\n  // Handle ResponseFormatUndefined case\n  if (\n    typeof responseFormat === \"object\" &&\n    responseFormat !== null &&\n    \"__responseFormatUndefined\" in responseFormat\n  ) {\n    return [];\n  }\n\n  /**\n   * If users provide an array, it should only contain raw schemas (Zod or JSON schema),\n   * not ToolStrategy or ProviderStrategy instances.\n   */\n  if (Array.isArray(responseFormat)) {\n    /**\n     * if every entry is a ToolStrategy or ProviderStrategy instance, return the array as is\n     */\n    if (\n      responseFormat.every(\n        (item) =>\n          item instanceof ToolStrategy || item instanceof ProviderStrategy\n      )\n    ) {\n      return responseFormat as unknown as ResponseFormat[];\n    }\n\n    /**\n     * Check if all items are Zod schemas\n     */\n    if (responseFormat.every((item) => isInteropZodObject(item))) {\n      return responseFormat.map((item) =>\n        ToolStrategy.fromSchema(item as InteropZodObject, options)\n      );\n    }\n\n    /**\n     * Check if all items are plain objects (JSON schema)\n     */\n    if (\n      responseFormat.every(\n        (item) =>\n          typeof item === \"object\" && item !== null && !isInteropZodObject(item)\n      )\n    ) {\n      return responseFormat.map((item) =>\n        ToolStrategy.fromSchema(item as JsonSchemaFormat, options)\n      );\n    }\n\n    throw new Error(\n      `Invalid response format: list contains mixed types.\\n` +\n        `All items must be either InteropZodObject or plain JSON schema objects.`\n    );\n  }\n\n  if (\n    responseFormat instanceof ToolStrategy ||\n    responseFormat instanceof ProviderStrategy\n  ) {\n    return [responseFormat];\n  }\n\n  const useProviderStrategy = hasSupportForJsonSchemaOutput(model);\n\n  /**\n   * `responseFormat` is a Zod schema\n   */\n  if (isInteropZodObject(responseFormat)) {\n    return useProviderStrategy\n      ? [ProviderStrategy.fromSchema(responseFormat)]\n      : [ToolStrategy.fromSchema(responseFormat, options)];\n  }\n\n  /**\n   * Handle plain object (JSON schema)\n   */\n  if (\n    typeof responseFormat === \"object\" &&\n    responseFormat !== null &&\n    \"properties\" in responseFormat\n  ) {\n    return useProviderStrategy\n      ? [ProviderStrategy.fromSchema(responseFormat as JsonSchemaFormat)]\n      : [ToolStrategy.fromSchema(responseFormat as JsonSchemaFormat, options)];\n  }\n\n  throw new Error(`Invalid response format: ${String(responseFormat)}`);\n}\n\n/**\n * Branded type for ToolStrategy arrays that preserves type information\n */\nexport interface TypedToolStrategy<T = unknown>\n  extends Array<ToolStrategy<any>> {\n  _schemaType?: T;\n}\nexport type ToolStrategyError =\n  | StructuredOutputParsingError\n  | MultipleStructuredOutputsError;\nexport interface ToolStrategyOptions {\n  /**\n   * Allows you to customize the message that appears in the conversation history when structured\n   * output is generated.\n   */\n  toolMessageContent?: string;\n  /**\n   * Handle errors from the structured output tool call. Using tools to generate structured output\n   * can cause errors, e.g. if:\n   * - you provide multiple structured output schemas and the model calls multiple structured output tools\n   * - if the structured output generated by the tool call doesn't match provided schema\n   *\n   * This property allows to handle these errors in different ways:\n   * - `true` - retry the tool call\n   * - `false` - throw an error\n   * - `string` - retry the tool call with the provided message\n   * - `(error: ToolStrategyError) => Promise<string> | string` - retry with the provided message or throw the error\n   *\n   * @default true\n   */\n  handleError?:\n    | boolean\n    | string\n    | ((error: ToolStrategyError) => Promise<string> | string);\n}\n\nexport function toolStrategy<T extends InteropZodType<any>>(\n  responseFormat: T,\n  options?: ToolStrategyOptions\n): TypedToolStrategy<T extends InteropZodType<infer U> ? U : never>;\nexport function toolStrategy<T extends readonly InteropZodType<any>[]>(\n  responseFormat: T,\n  options?: ToolStrategyOptions\n): TypedToolStrategy<\n  { [K in keyof T]: T[K] extends InteropZodType<infer U> ? U : never }[number]\n>;\nexport function toolStrategy(\n  responseFormat: JsonSchemaFormat,\n  options?: ToolStrategyOptions\n): TypedToolStrategy<Record<string, unknown>>;\nexport function toolStrategy(\n  responseFormat: JsonSchemaFormat[],\n  options?: ToolStrategyOptions\n): TypedToolStrategy<Record<string, unknown>>;\n\n/**\n * Define how to transform the response format from a tool call.\n *\n * @param responseFormat - The response format to transform\n * @param options - The options to use for the transformation\n * @param options.handleError - Whether to handle errors from the tool call\n * @returns The transformed response format\n */\nexport function toolStrategy(\n  responseFormat:\n    | InteropZodType<any>\n    | InteropZodType<any>[]\n    | JsonSchemaFormat\n    | JsonSchemaFormat[],\n  options?: ToolStrategyOptions\n): TypedToolStrategy {\n  return transformResponseFormat(responseFormat, options) as TypedToolStrategy;\n}\n\nexport function providerStrategy<T extends InteropZodType<any>>(\n  responseFormat: T\n): ProviderStrategy<T extends InteropZodType<infer U> ? U : never>;\nexport function providerStrategy(\n  responseFormat: JsonSchemaFormat\n): ProviderStrategy<Record<string, unknown>>;\nexport function providerStrategy(\n  responseFormat: InteropZodType<any> | JsonSchemaFormat\n): ProviderStrategy<any> {\n  return ProviderStrategy.fromSchema(\n    responseFormat as any\n  ) as ProviderStrategy<any>;\n}\n\n/**\n * Type representing a JSON Schema object format.\n * This is a strict type that excludes ToolStrategy and ProviderStrategy instances.\n */\nexport type JsonSchemaFormat = {\n  type:\n    | \"null\"\n    | \"boolean\"\n    | \"object\"\n    | \"array\"\n    | \"number\"\n    | \"string\"\n    | \"integer\";\n  properties?: Record<string, unknown>;\n  required?: string[];\n  additionalProperties?: boolean;\n  [key: string]: unknown;\n} & {\n  // Brand to ensure this is not a ToolStrategy or ProviderStrategy\n  __brand?: never;\n};\n\nconst CHAT_MODELS_THAT_SUPPORT_JSON_SCHEMA_OUTPUT = [\"ChatOpenAI\", \"ChatXAI\"];\nconst MODEL_NAMES_THAT_SUPPORT_JSON_SCHEMA_OUTPUT = [\n  \"grok\",\n  \"gpt-5\",\n  \"gpt-4.1\",\n  \"gpt-4o\",\n  \"gpt-oss\",\n  \"o3-pro\",\n  \"o3-mini\",\n];\n\n/**\n * Identifies the models that support JSON schema output\n * @param model - The model to check\n * @returns True if the model supports JSON schema output, false otherwise\n */\nexport function hasSupportForJsonSchemaOutput(\n  model?: LanguageModelLike | string\n): boolean {\n  if (!model) {\n    return false;\n  }\n\n  if (typeof model === \"string\") {\n    const modelName = model.split(\":\").pop() as string;\n    return MODEL_NAMES_THAT_SUPPORT_JSON_SCHEMA_OUTPUT.some(\n      (modelNameSnippet) => modelName.includes(modelNameSnippet)\n    );\n  }\n\n  if (isConfigurableModel(model)) {\n    const configurableModel = model as unknown as {\n      _defaultConfig: { model: string };\n    };\n    return hasSupportForJsonSchemaOutput(\n      configurableModel._defaultConfig.model\n    );\n  }\n\n  if (!isBaseChatModel(model)) {\n    return false;\n  }\n\n  const chatModelClass = model.getName();\n\n  /**\n   * for testing purposes only\n   */\n  if (chatModelClass === \"FakeToolCallingChatModel\") {\n    return true;\n  }\n\n  if (\n    CHAT_MODELS_THAT_SUPPORT_JSON_SCHEMA_OUTPUT.includes(chatModelClass) &&\n    /**\n     * OpenAI models\n     */ ((\"model\" in model &&\n      MODEL_NAMES_THAT_SUPPORT_JSON_SCHEMA_OUTPUT.some(\n        (modelNameSnippet) =>\n          typeof model.model === \"string\" &&\n          model.model.includes(modelNameSnippet)\n      )) ||\n      /**\n       * for testing purposes only\n       */\n      (chatModelClass === \"FakeToolCallingModel\" &&\n        \"structuredResponse\" in model))\n  ) {\n    return true;\n  }\n\n  return false;\n}\n"],"mappings":"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"}