import { MessagesZodMeta } from "@langchain/langgraph";
import { z } from "zod/v3";
import { schemaMetaRegistry, withLangGraph } from "@langchain/langgraph/zod";

//#region src/agents/annotation.ts
function createAgentAnnotationConditional(hasStructuredResponse = true, stateSchema, middlewareList = []) {
	/**
	* Create Zod schema object to preserve jsonSchemaExtra
	* metadata for LangGraph Studio using v3-compatible withLangGraph
	*/
	const schemaShape = {
		messages: withLangGraph(z.custom(), MessagesZodMeta),
		jumpTo: z.union([
			z.literal("model_request"),
			z.literal("tools"),
			z.literal("end"),
			z.undefined()
		]).optional()
	};
	const applySchema = (schema) => {
		const { shape } = schema;
		for (const [key, schema$1] of Object.entries(shape)) {
			/**
			* Skip private state properties
			*/
			if (key.startsWith("_")) continue;
			if (!(key in schemaShape)) schemaShape[key] = schema$1;
		}
	};
	if (stateSchema && "shape" in stateSchema) applySchema(stateSchema);
	for (const middleware of middlewareList) if (middleware.stateSchema) applySchema(middleware.stateSchema);
	if (hasStructuredResponse) schemaShape.structuredResponse = z.any().optional();
	const zodSchema = z.object(schemaShape);
	const stateDefinition = schemaMetaRegistry.getChannelsForSchema(zodSchema);
	return stateDefinition;
}
const PreHookAnnotation = z.object({
	llmInputMessages: withLangGraph(z.custom(), {
		reducer: { fn: (_x, update) => MessagesZodMeta.reducer.fn([], update) },
		default: () => []
	}),
	messages: withLangGraph(z.custom(), MessagesZodMeta)
});

//#endregion
export { createAgentAnnotationConditional };
//# sourceMappingURL=annotation.js.map