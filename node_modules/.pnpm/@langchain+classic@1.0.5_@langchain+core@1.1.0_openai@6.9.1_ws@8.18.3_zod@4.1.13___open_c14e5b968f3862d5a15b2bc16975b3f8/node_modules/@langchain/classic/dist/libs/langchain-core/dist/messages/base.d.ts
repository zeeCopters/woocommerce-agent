import { ContentBlock } from "./content/index.js";
import { Serializable } from "../load/serializable.js";
import { MessageStringFormat } from "./format.js";
import { $InferMessageContent, $InferResponseMetadata, Message, MessageStructure, MessageType } from "./message.js";

//#region ../langchain-core/dist/messages/base.d.ts

//#region src/messages/base.d.ts
/** @internal */
declare const MESSAGE_SYMBOL: unique symbol;
interface StoredMessageData {
  content: string;
  role: string | undefined;
  name: string | undefined;
  tool_call_id: string | undefined;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  additional_kwargs?: Record<string, any>;
  /** Response metadata. For example: response headers, logprobs, token counts, model name. */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  response_metadata?: Record<string, any>;
  id?: string;
}
interface StoredMessage {
  type: string;
  data: StoredMessageData;
}
interface FunctionCall {
  /**
   * The arguments to call the function with, as generated by the model in JSON
   * format. Note that the model does not always generate valid JSON, and may
   * hallucinate parameters not defined by your function schema. Validate the
   * arguments in your code before calling your function.
   */
  arguments: string;
  /**
   * The name of the function to call.
   */
  name: string;
}
type BaseMessageFields<TStructure extends MessageStructure = MessageStructure, TRole extends MessageType = MessageType> = {
  id?: string;
  name?: string;
  content?: $InferMessageContent<TStructure, TRole>;
  contentBlocks?: Array<ContentBlock.Standard>;
  /** @deprecated */
  additional_kwargs?: {
    /**
     * @deprecated Use "tool_calls" field on AIMessages instead
     */
    function_call?: FunctionCall;
    /**
     * @deprecated Use "tool_calls" field on AIMessages instead
     */
    tool_calls?: OpenAIToolCall[];
    [key: string]: unknown;
  };
  response_metadata?: Partial<$InferResponseMetadata<TStructure, TRole>>;
};
/**
 * Base class for all types of messages in a conversation. It includes
 * properties like `content`, `name`, and `additional_kwargs`. It also
 * includes methods like `toDict()` and `_getType()`.
 */
declare abstract class BaseMessage<TStructure extends MessageStructure = MessageStructure, TRole extends MessageType = MessageType> extends Serializable implements Message<TStructure, TRole> {
  lc_namespace: string[];
  lc_serializable: boolean;
  get lc_aliases(): Record<string, string>;
  readonly [MESSAGE_SYMBOL]: true;
  abstract readonly type: TRole;
  id?: string;
  name?: string;
  content: $InferMessageContent<TStructure, TRole>;
  additional_kwargs: NonNullable<BaseMessageFields<TStructure, TRole>["additional_kwargs"]>;
  response_metadata: NonNullable<BaseMessageFields<TStructure, TRole>["response_metadata"]>;
  /**
   * @deprecated Use .getType() instead or import the proper typeguard.
   * For example:
   *
   * ```ts
   * import { isAIMessage } from "@langchain/core/messages";
   *
   * const message = new AIMessage("Hello!");
   * isAIMessage(message); // true
   * ```
   */
  _getType(): MessageType;
  /**
   * @deprecated Use .type instead
   * The type of the message.
   */
  getType(): MessageType;
  constructor(arg: $InferMessageContent<TStructure, TRole> | BaseMessageFields<TStructure, TRole>);
  /** Get text content of the message. */
  get text(): string;
  get contentBlocks(): Array<ContentBlock.Standard>;
  toDict(): StoredMessage;
  static lc_name(): string;
  // Can't be protected for silly reasons
  get _printableFields(): Record<string, unknown>;
  static isInstance(obj: unknown): obj is BaseMessage;
  // this private method is used to update the ID for the runtime
  // value as well as in lc_kwargs for serialisation
  _updateId(value: string | undefined): void;
  get [Symbol.toStringTag](): any;
  toFormattedString(format?: MessageStringFormat): string;
}
/**
 * @deprecated Use "tool_calls" field on AIMessages instead
 */
type OpenAIToolCall = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The function that the model called.
   */
  function: FunctionCall;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: "function";
  index?: number;
};
//#endregion
export { BaseMessage };
//# sourceMappingURL=base.d.ts.map